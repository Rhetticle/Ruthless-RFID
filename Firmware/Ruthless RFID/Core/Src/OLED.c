/*
 * OLED.c
 *
 *  Created on: Jan 29, 2024
 *      Author: rhett
 */

#include "OLED.h"
#include "MFRC.h"
#include "stm32f4xx.h"
#include "usbd_cdc_if.h"


// 'Capture1', 128x64px HVE logo
uint8_t HVE[] = {
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f,
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x80, 0xe0, 0xf0, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x07, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
		0xe0, 0xf0, 0xfc, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x01, 0x01,
		0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x01, 0x01,
		0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe1, 0x81, 0x01, 0x01, 0x07, 0x3f, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x0f, 0x03, 0x01, 0x01, 0xe1, 0xf9, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1,
		0xe1, 0xe1, 0xe1, 0xf3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x0f, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xe0, 0xf8, 0xfc, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xff, 0xff, 0xff, 0x8f, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x07, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xe0, 0x00, 0x00, 0x01, 0x07, 0x3f, 0xff,
		0xff, 0xff, 0xff, 0x0f, 0x01, 0x00, 0x80, 0xe0, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87,
		0x87, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0x1e,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x81, 0xc1, 0xe1, 0xf1, 0xf9,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xc0, 0x00, 0x00, 0x01,
		0x0f, 0x7f, 0xff, 0xfe, 0xf8, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
		0x3f, 0x3f, 0x3f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x0f, 0x01, 0x00,
		0x00, 0x00, 0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfc, 0xfc,
		0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xfc, 0xfc,
		0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfc, 0xfc,
		0xfc, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc,
		0xfc, 0xfc, 0xfc, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x83, 0xc0, 0xe0, 0xf0, 0xf8,
		0xfc, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
	};

// Array of all bitmaps for convenience. (Total bytes used to store images in PROGMEM = 1040)


/**
 * Screens
 *
 * */

const Screen home = {
		.datsize = sizeof(HOME_SCREEN)/sizeof(HOME_SCREEN[0]),
		.selsize = sizeof(HOME_SEL)/sizeof(HOME_SEL[0]),
		.data = HOME_SCREEN,
		.dataloc = HOME_DATLOC,
		.seldata = HOME_SEL,

};

const Screen read_card = {
		.datsize = sizeof(READ_SCREEN)/sizeof(READ_SCREEN[0]),
		.selsize = sizeof(READ_SEL)/sizeof(READ_SEL[0]),
		.data = READ_SCREEN,
		.dataloc = READ_DATLOC,
		.seldata = READ_SEL,

};

const Screen card_found = {
		.datsize = sizeof(CARD_FOUNDSCREEN)/sizeof(CARD_FOUNDSCREEN[0]),
		.selsize = sizeof(CARD_FOUNDSEL)/sizeof(CARD_FOUNDSEL[0]),
		.data = CARD_FOUNDSCREEN,
		.dataloc = CARD_FOUNDATLOC,
		.seldata = CARD_FOUNDSEL,

};

const Screen write_card = {
		.datsize = sizeof(WRITE_SCREEN)/sizeof(WRITE_SCREEN[0]),
		.selsize = sizeof(WRITE_SEL)/sizeof(WRITE_SEL[0]),
		.data = WRITE_SCREEN,
		.dataloc = WRITE_DATLOC,
		.seldata = WRITE_SEL,

};


/* Function to turn off OLED (sends 0xAE)
 *
 * */
void OLED_OFF(void){
	uint8_t off_op=0xAE;
	HAL_GPIO_WritePin(GPIOA, OLED_CS, 0);
	HAL_SPI_Transmit(&hspi1,&off_op , 1, 100);
	HAL_GPIO_WritePin(GPIOA, OLED_CS, 1);
}
/*Function to clear OLED (write all zero to display memory)
 *
 * */
void OLED_Clear(void){
	uint8_t zeros[1024];
	memset(zeros,0x00,1024);
	OLED_FLUSH(zeros);

}

/*Function to send single byte command to display (ENSURE DC is low)
 *
 * @param data: Command to send to display
 * */
HAL_StatusTypeDef OLED_cmd(uint8_t data){
	uint8_t value=data;
	HAL_GPIO_WritePin(GPIOA, OLED_CS, 0);
	HAL_GPIO_WritePin(GPIOB, OLED_DC, 0);
	if(HAL_SPI_Transmit(&hspi1, &value, 1, HAL_MAX_DELAY)!=HAL_OK){
		HAL_GPIO_WritePin(GPIOA, OLED_CS, 1);
		HAL_Delay(1);
		return(HAL_ERROR);
	}
	else{
		HAL_GPIO_WritePin(GPIOA, OLED_CS, 1);
		HAL_Delay(1);
		return(HAL_OK);
	}

}

/*Function to send display data/write to memory in display (ENSURE DC is high)
 *
 * @param data: Pointer to array of data to send
 *
 * @param size: Size of array (maximum is 1024)
 * */
HAL_StatusTypeDef OLED_data(uint8_t* data,uint8_t size){
	HAL_GPIO_WritePin(GPIOA, OLED_CS, 0);
	HAL_GPIO_WritePin(GPIOB, OLED_DC, 1);
	if(HAL_SPI_Transmit(&hspi1, data, size, HAL_MAX_DELAY)!=HAL_OK){
		HAL_GPIO_WritePin(GPIOB, OLED_DC, 0);
		HAL_GPIO_WritePin(GPIOA, OLED_CS, 1);
		return(HAL_ERROR);
	}
	else{
		HAL_GPIO_WritePin(GPIOB, OLED_DC, 0);
		HAL_GPIO_WritePin(GPIOA, OLED_CS, 1);
		return(HAL_OK);
	}



}

/*Function to send a whole page of display data (1024 bytes)
 *
 * @param mem: Pointer to array of data
 * */
void OLED_FLUSH(uint8_t* mem){
	for(int page=0;page<8;page++){
		OLED_cmd(PAGE_ADDR+page);
		OLED_cmd(LOWER_COL);
		OLED_cmd(UPPER_COL);
		for(int i=0;i<128;i++){
			OLED_data(&mem[(page*128)+i],1);
		}


	}
}

/*Function to initialise a Screen struct member
 *
 * @param screen: Pointer to screen we want to initialise
 *
 * @param datasize: Number of strings in data variable
 *
 * @param selsize: Number of inner arrays in seldata variable
 *
 * @param data: Array of strings that form the basis of the screen
 *
 * @param seldata: Array of data on where to place select arrow "->"
 * */

void SCREEN_INIT(Screen* screen,int datasize,int selsize,char** data,uint8_t (*dataloc)[2],uint8_t (*seldata)[2]){

    screen->datsize=datasize;
    screen->selsize=selsize;
    screen->data=data;
    screen->dataloc=dataloc;
    screen->seldata=seldata;



}


/*Function to initialise OLED display
 *
 * */

HAL_StatusTypeDef OLED_INIT(void){
	HAL_GPIO_WritePin(GPIOA, OLED_CS, 1);
	HAL_GPIO_WritePin(GPIOA, OLED_RST, 1);
	HAL_GPIO_WritePin(GPIOB, OLED_DC, 0);
	HAL_Delay(100);
	HAL_GPIO_WritePin(GPIOA, OLED_RST, 0);
	HAL_Delay(100);
	HAL_GPIO_WritePin(GPIOA, OLED_RST, 1);
	HAL_Delay(100);
	uint8_t config_data[25]={DISP_OFF , LOWER_COL , UPPER_COL , LINE_STRT , PAGE_ADDR , CNTRST_SET , CNTRST , SEG_MAP ,
							DISP_NORM , MUX_SET , MUX , DCDC_SET , DCDC , CHRG_PMP , SCAN_DIR , DISP_OFFSET_SET ,
							DISP_OFFSET , OSC_SET , OSC , PRE_CHRG_SET , PRE_CHRG , COM_SET , COM , VCOM_SET, VCOM};


	for(int i=0;i<25;i++){
		OLED_cmd(config_data[i]);
		HAL_Delay(1);
	}

	OLED_cmd(DISP_INV);
	OLED_FLUSH(HVE);
	OLED_cmd(DISP_ON);
	HAL_Delay(1000);
	OLED_cmd(DISP_OFF);
	HAL_Delay(10);
	OLED_cmd(DISP_NORM);
	HAL_Delay(10);
	OLED_cmd(DISP_ON);
	OLED_Clear();


}


/*Function to invert the characters from ASCII in OLED.h (Default is 1 is on 0 is off)
 *
 * @param character: Character to invert (Must be an ASCII character)
 *
 * @param result: Pointer to array to store the 5 inverted bytes that make up the character
 * */
void OLED_InvChar(char character,uint8_t* result){
	uint8_t* temp=malloc(5);

	for(int i=0;i<6;i++){
			temp[i]=~(ASCII[(uint8_t)character-0x20][i]);
	}
	memcpy(result,temp,5);
	free(temp);
}

/*Function to draw a single character on the display
 *
 * @param page: Row to write on (Display has 8 pages/rows)
 *
 * @param col: Column to begin writing (Display has 128 columns)
 *
 * @param character: Character to draw
 *
 * @param invert: Option to invert the character (Use INVERT to invert defined in OLED.h)
 * */

void OLED_drawChar(uint8_t page,uint8_t col, char character, uint8_t invert){
	OLED_cmd(PAGE_ADDR+page);
	OLED_cmd(col&0x0F);
	OLED_cmd(0x10|(col>>4));
	uint8_t* data=malloc(6);
	if(invert==NORMAL){
		memcpy(data,ASCII[(uint8_t)character-0x20],5);
	}
	else{
		OLED_InvChar(character,data);
	}

	*(data+5)=0x00;
	OLED_data(data, 6);
	free(data);
	}

/*Function to write string on a certain line of display
 *
 * @param page: Row to write on (Display has 8 pages/rows)
 *
 * @param col: Column to begin writing (Display has 128 columns)
 *
 * @param string: String to print (MUST BE LESS THAN 21)
 *
 * @param invert: Option to invert the entire string
 * */

void OLED_Printlin(uint8_t page,uint8_t col,char* string,uint8_t invert){
	for(int i=0;i<strlen(string);i++){

			OLED_drawChar(page, col+(i*6), string[i],invert);


	}
}

/*Function to shift a string over a certain number of spaces
 *
 * @param page: OLED page where string is
 *
 * @param start_col: Column location of first character in string
 *
 * @param spaces: Number of spaces to shift string
 *
 * @param dir: Direction to shift string (OLED_LEFT or OLED_RIGHT)
 *
 * @param string: String to shift
 * */

void OLED_Shift(uint8_t page,uint8_t start_col,uint8_t spaces, uint8_t dir, char* string){

	char data[strlen(string)+spaces];

	memset(data,' ',spaces); //Fill start of array with whitespace
	strcpy(data+spaces,string); //Fill resting of data with string we want to shift

	OLED_Printlin(page, start_col, data, NORMAL);
}

/*Function to print a single line center justified
 *
 * @param page: Page to print string to
 *
 * @param string: String to print
 *
 * @param invert: Option to invert text
 * */

void OLED_PrintCent(uint8_t page, char* string, uint8_t invert){
	int len=strlen(string);

	int start_col=(MID_COL)-((len/2)*6);

	OLED_Printlin(page, start_col, string, invert);
}

/*General purpose print function with wrap around ability. (Can take string of abitrary size and fit onto display)
 *
 * @param string: String to print (This can be longer than the max 21 character per line this function will chop it up)
 * */

void OLED_Print(char* string){
	char fill = ' ';
	int i=0;
	int last_ind=0;
	int line=0;
	int linend=0;

	    while(1){

	        char thisline[22];
	        char whitespaces[20];

	        for(int charac=0;charac<22;charac++){
	            if(string[last_ind+charac]==' '){
	                whitespaces[i]=charac; //keep track of our whitespaces
	                i++;
	            }
	            else{
	                continue;
	            }


	        }

	        if(string[last_ind]==' '){
	            last_ind++;
	        }

	        else{

	        }

	        if(strlen(string+last_ind)<22){ //special routine for end of line (since string[last_ind+20] may not exist)
	            linend=strlen(string+last_ind);
	            strncpy(thisline,string+last_ind,linend); //i-1 since the last loop of whitespaces will increment i i.e. if 4 whitespaces in first 21 characters whitespaces[3] will be last index
	            memset(thisline+linend,fill,21-linend);
	            thisline[21]=' ';
	            OLED_Printlin(line, 0x02,thisline,NORMAL);
	            break;
	        }

	        else{
	        if((string[(last_ind)+20]!=' ') && (string[(last_ind)+21]!=' ')){
	            strncpy(thisline,string+last_ind,whitespaces[i-1]); //i-1 since the last loop of whitespaces will increment i i.e. if 4 whitespaces in first 21 characters whitespaces[3] will be last index
	            memset(thisline+whitespaces[i-1],fill,21-whitespaces[i-1]);
	            thisline[21]=' ';
	            last_ind=last_ind+whitespaces[i-1];

	            }

	        else{
	            strncpy(thisline,string+last_ind,21);
	            thisline[21]=' ';
	            last_ind=last_ind+21;

	        }
	        }
	        i=0;
	        OLED_Printlin(line, 0x02, thisline,NORMAL);
	        line++;





	    }
}

/*Function to display a Screen e.g. HOME, Read card etc
 *
 * @param screen: Screen to display
 *
 * @param invert: Option to invert entire screen
 * */

void OLED_SCREEN(Screen* screen,uint8_t invert){
	OLED_Clear();
	OLED_PrintCent(0, screen->data[0], invert);

	for(int i=0;i<screen->datsize-1;i++){
		OLED_Printlin(screen->dataloc[i+1][0], screen->dataloc[i+1][1], screen->data[i+1], invert);
	}
}

void OLED_FREESCREEN(Screen* screen){
	for(int i=0;i<screen->datsize;i++){
		free(screen->data[i]);
		free(screen->dataloc[i]);
	}
	for(int j=0;j<screen->selsize;j++){
		free(screen->seldata[j]);
	}

}

/*Function to add dynamic data to base screen i.e. adding UID read from card to display
 *
 * @param screen: Base screen to add data to
 *
 * @param dataindx: Index of screen->data to modify
 *
 * @param data: Data to add to the screen
 * */

void OLED_SCRNREF(Screen* screen,uint8_t dataindx,char* data){
	int len=strlen(screen->data[dataindx]);
	int start_col=START_COL+((len)*6);

	OLED_Printlin(screen->dataloc[dataindx][0], start_col, data, NORMAL);
}

/*Function to fill area of display with certain character
 *
 * @param data: Single byte of data to fill screen with
 *
 * @param page: Row to begin writing
 *
 * @param col: Column to begin writing (Display has 128 columns)
 *
 * @param length: Length of fill
 * */

void OLED_FILL(uint8_t* data,uint8_t page,uint8_t start_col, uint8_t length){
	OLED_cmd(PAGE_ADDR+page);
	OLED_cmd(start_col&0x0F);
	OLED_cmd(0x10|(start_col>>4));
	for(int i=0;i<length*6;i++){
		OLED_data(data, 1);

	}
}

/*Function to place the select arrow at certain position of display
 *
 * @param page: Row to place arrow
 *
 * @param col: Column to place arrow
 * */

void OLED_SELECT(Screen* screen,uint8_t selopt, int restore){

	char arrow[]="->";

	uint8_t prevpage,prevcol,thispage,thiscol;
	char* rest;

		if(restore==OLED_RESTORE){
			if(selopt==0){
			rest=screen->data[screen->datsize-1]; //Here we may be wrapping around so we must restore the last select option
			}
			else{
				rest=screen->data[selopt];
			}
		}
		else{
			rest="  ";
		}

	    if(selopt==0){
	        prevpage=screen->seldata[screen->selsize-1][0];
	        prevcol=screen->seldata[screen->selsize-1][1];
	        thispage=screen->seldata[selopt][0];
	        thiscol=screen->seldata[selopt][1];





	    }
		else{
	        prevpage=screen->seldata[selopt-1][0]; //See OLED.h this will give the page of the previous select option
		    prevcol=screen->seldata[selopt-1][1];
		    thispage=screen->seldata[selopt][0];
	        thiscol=screen->seldata[selopt][1];

	    }

	    OLED_Printlin(prevpage, prevcol, rest, NORMAL); //This restores the line of the previous (now deselected) select option
	    OLED_Printlin(thispage, thiscol, arrow, NORMAL);

}

/*Function to perform the display's power down sequence
 * */

void OLED_PWRDWN(void){
	OLED_OFF();
	uint8_t data[]={0x8D,0x10};
	OLED_cmd(data[0]);
	HAL_Delay(1);
	OLED_cmd(data[1]);
}
